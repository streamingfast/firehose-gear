package gen_types

import (
    "github.com/centrifuge/go-substrate-rpc-client/v4/registry"
    "github.com/centrifuge/go-substrate-rpc-client/v4/types"
    pbgear "github.com/streamingfast/firehose-gear/pb/sf/gear/metadata/type/v1"
)

{{- $generator := . }}
{{- $metadata := $generator.Metadata }}
{{- $messages := $generator.Messages }}

{{- range $msg := $messages }}
{{/*{{- if or (eq $msg.Pallet "") (eq $msg.Pallet "")}}*/}}
{{- $funcName := $msg.ToFuncName $metadata }}
{{- if eq $funcName "To_TupleNull" }}
    func {{ $funcName }}() {{ $msg.ReturnType $metadata }} {
{{- else }}
    func {{ $funcName }}(in {{ $generator.TypeForField $msg }}) {{ $msg.ReturnType $metadata }} {
{{- end }}
    {{template "funcBody" wrap (newWrapItem "lookable" $msg "fields" $msg.Fields "outputType" ($msg.OutputType $metadata) "parentFullTypeName" ($msg.FullTypeName)) }}
    }

{{- range $field := $msg.Fields }}
    {{- template "fieldFunc" wrap (newWrapItem "field" $field) -}}
{{- end }} {{- /* range fields */}}

{{- end }} {{- /* range messages */}}
{{/*{{- end }}*/}}

{{ define "funcBody" }}
    {{- $lookable := .lookable }}
    {{- $fields := .fields }}
    {{- $generator := .generator }}
    {{- $meta := .generator.Metadata }}
    {{- $outputType := .outputType }}
    {{- $parentFullTypeName := .parentFullTypeName }}
    {{- $type := $generator.TypeForField $lookable }}
    {{- if eq $type "types.UCompact"}}
        {{- $field := index $fields 0 }}
        {{- $childType := $generator.CompactChildType $field  }}
        {{- if $childType.IsPrimitive }}
            //{{ $outputType }}
            panic("types.UCompact primitive")
        {{- else }}
            out := {{ $outputType }}{}
            _ = out
            {{- $funcName := $field.ToFuncName $meta }}
            {{- if hasSuffix $outputType "TupleNull"}}
            out.{{ $field.ToFieldName }} = {{ $funcName }}()
            {{- else }}
            // else types.UCompact
            panic("else types.UCompact")
{{/*            out.{{ $field.ToFieldName }} = {{ $funcName }}(in)*/}}
            {{- end }}
            return out
        {{- end }}
    {{- else }}

        {{- if hasSuffix $outputType "TupleNull"}}
        {{- else }}
            // funcBody
            fields := []*registry.DecodedField(in)
            _ = fields
        {{- end}}
    {{- template "return" wrap (newWrapItem "fields" $fields "outputType" $outputType "parentFullTypeName" $parentFullTypeName) }}
    {{- end }}
{{- end }}

{{- /* ============================= */}}
{{- /* RETURN                        */}}
{{- /* ============================= */}}
{{ define "return" }}
{{- $generator := .generator }}
{{- $meta := .generator.Metadata }}
{{- $fields := .fields }}
{{- $outputType := .outputType }}
{{- $parentFullTypeName := .parentFullTypeName }}
    out := {{ $outputType }}{}

    {{- range $i, $field := $fields }}
    {{- if $field.IsOneOf }}
        {{ template "oneOfSwitch" wrap (newWrapItem "field" $field "msgOutputType" $outputType "parentFullTypeName" $parentFullTypeName)}}
    {{- else }}
        {{- if eq $field.Type "bytes"}}
            out.{{ $field.ToFieldName }} = {{ $field.ToFuncName $meta }}(fields[{{$i}}].Value.([]interface{}))
        {{- else }}
            {{- $funcName := $field.ToFuncName $meta }}
            {{- if eq $funcName "To_TupleNull" }}
            out.{{ $field.ToFieldName }} = {{ $funcName }}()
            {{- else }}
                {{- $type := $generator.TypeForField $field }}

                {{- if eq $type "types.UCompact"}}
                    {{- $childType := $generator.CompactChildType $field  }}
                    {{- if $childType.IsPrimitive }}
                        panic("return types.UCompact primitive")
                    {{- else }}
            // return else types.UCompact IsPrimitive
            out.{{ $field.ToFieldName }} = {{ $funcName }}(fields[{{$i}}].Value.(types.UCompact))
                    {{- end }}
                {{- else }}
            out.{{ $field.ToFieldName }} = {{ $funcName }}(fields[{{$i}}].Value.({{ $type }}))
                {{- end }}
            {{- end }}
        {{- end }}
    {{- end }}
    {{- end }}
    return out
{{- end -}}

{{- /* ============================= */}}
{{- /* FIELD FUNC                        */}}
{{- /* ============================= */}}
{{ define "fieldFunc" }}
    {{- $field := .field }}
    {{- $meta := .generator.Metadata }}
    {{- $generator := .generator }}
    {{- if not $field.IsPrimitive }}
        {{- /* ============================= */}}
        {{- /* NOT PRIMITIVE                 */}}
        {{- /* ============================= */}}
        {{- if $field.IsOptional }}
            {{- $optKey := printf "%sopt%t" $field.FullTypeName $field.IsOptional}}
            {{- $seen := $generator.IsSeen $optKey }}
            {{- if not $seen }}
                {{- template "optionalField" wrap (newWrapItem "field" $field) }}
                {{- $ignore := $generator.Seen $optKey}}
            {{- end }}
        {{- end}}
        {{- if $field.IsRepeated }}
            {{- $repKey := printf "%srep%t" $field.FullTypeName $field.IsRepeated}}
            {{- $seen := $generator.IsSeen $repKey }}
            {{- if not $seen }}
                {{- template "repeatedField" wrap (newWrapItem "field" $field) }}
                {{- $ignore := $generator.Seen $repKey}}
            {{- end }}
        {{- end }}

    {{- end }}
{{- end }}


{{- /* ============================= */}}
{{- /* TODO ONE OF FIELD SELECTION   */}}
{{- /* ============================= */}}


{{- /* ============================= */}}
{{- /* REPEATED FIELD                */}}
{{- /* ============================= */}}
{{ define "repeatedField" }}
{{- $field := .field }}
{{- $generator := .generator }}
{{- $meta := .generator.Metadata }}
{{- $goType := $field.ToGoTypeName $meta }}
func {{ $field.ToFuncName $meta}}(f {{ $generator.TypeForField $field }}) {{ $field.ReturnType $meta }} {
    fields := []*registry.DecodedField(f)
    _ = fields

    out := make([]*{{ $goType }}, len(fields))
    for _, f := range fields {
        out = append(out, {{$field.ToChildFuncName $meta}}(f.Value.([]*registry.DecodedField)))
    }
    return out
}
{{- end }}
{{- /* ============================= */}}
{{- /* OPTIONAL FIELD                */}}
{{- /* ============================= */}}
{{ define "optionalField" }}
    {{- $field := .field }}
    {{- $generator := .generator }}
    {{- $meta := .generator.Metadata }}
    {{- $goType := $field.ToGoTypeName $meta }}
    func {{ $field.ToFuncName $meta}}(f {{ $generator.TypeForField $field }}) {{ $field.ReturnType $meta }} {
        fields := []*registry.DecodedField(f)
        _ = fields

        var out = {{$field.ToChildFuncName $meta}}(fields)
        return out
    }
{{- end }}

{{- /* ============================= */}}
{{- /* ONE OF SWITCH                 */}}
{{- /* ============================= */}}
{{ define "oneOfSwitch" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $generator := .generator }}
{{- $msgOutputType := .msgOutputType }}
{{- $parentFullTypeName := .parentFullTypeName }}

{{- $idToField := .generator.IdToField }}
{{- $goType := $field.ToGoTypeName $meta }}
{{- $variantChildIds := $generator.VariantChildIds $field.LookupID}}
    switch {
    {{- range $i, $ids := $variantChildIds }}
    {{- $t := index $field.Types $i}}
    case matchFields(fields, {{$ids}}):
        out.{{$field.ToFieldName}} = &pbgear.{{$parentFullTypeName}}_{{$t.ToFieldName}}{
            {{$t.ToFieldName}}: {{ $t.ToFuncName $meta}}(fields), //Passthrough fields...
        }
    {{- end }}
    }
{{- end -}}


func matchFields(f registry.DecodedFields, ids []int64) bool {
    fields := []*registry.DecodedField(f)

	if len(fields) != len(ids) {
		return false
	}
	for i, f := range fields {
		if ids[i] != f.LookupIndex{
			return false
		}
	}
	return true
}

func To_bytes(f []interface{}) []byte {
    var out []byte
    for _, f := range f {
        u := uint8(f.(types.U8))
        out = append(out, byte(u))
    }
    return out
}

//func (t *Type) ToProtoType(options ...string) string {
//	if t.IsBool {
//		return "bool"
//	}
//
//	if t.IsChar || t.IsStr || t.IsU128 || t.IsU256 || t.IsI128 || t.IsI256 {
//		return "string"
//	}
//
//	if t.IsU8 {
//		return "uint8"
//	}
//
//	if t.IsI8 {
//		return "int8"
//	}
//
//	if t.IsU16 || t.IsU32 {
//		return "uint32"
//	}
//
//	if t.IsU64 {
//		return "uint64"
//	}
//
//	if t.IsI16 || t.IsI32 {
//		return "int32"
//	}
//
//	if t.IsI64 {
//		return "int64"
//	}
//
//	panic("unknown type")
//}

func To_string(i any) string {
    switch v := i.(type) {
    case types.Text:
        return string(v)
    case types.U128:
        return v.String()
    case types.U256:
        return v.String()
    case types.I128:
        return v.String()
    case types.I256:
        return v.String()
    default:
        panic("Unknown type")
    }
}

func To_uint32(i any) uint32 {
    switch v := i.(type) {
    case types.U8:
        return uint32(v)
    case types.U16:
        return uint32(v)
    case types.U32:
        return uint32(v)
    default:
        panic("Unknown type")
    }
}

func To_optional_uint32(i any) *uint32 {
    o := To_uint32(i)
    return &o
}

func To_uint64(i types.U64) uint64 {
    return uint64(i)
}

func To_optional_uint64(i types.U64) *uint64 {
    o := uint64(i)
    return &o
}

func To_bool(b types.Bool) bool {
    return bool(b)
}

func To_optional_string(a any) *string {
    s := To_string(a)
    return &s
}


func To_optional_bool(i types.Bool) *bool {
    o := bool(i)
    return &o
}

func To_repeated_uint32(a any) []uint32 {
    panic("To_repeated_uint32")
}
