package gen_types

import (
    "github.com/centrifuge/go-substrate-rpc-client/v4/registry"
    pbgear "github.com/streamingfast/firehose-gear/pb/sf/gear/metadata/type/v1"
    "reflect"
)

{{- $generator := . }}
{{- $metadata := $generator.Metadata }}
{{- $messages := $generator.Messages }}
{{- $idToField := $generator.IdToField }}

type regEntry struct{
    fn func(fields []*registry.DecodedField) any
    returnType reflect.Type
}

var reg map[int64]*regEntry

func init() {
	reg = make(map[int64]*regEntry)
    {{- range $k, $f:= $idToField}}
        reg[{{$k}}] = &regEntry{
            fn: {{$f.ToFuncName $metadata}},
            {{/* returnType: "{{$f.ToGoTypeName $metadata}}", */}}
        }
    {{- end}}
}


{{ range $msg := $messages }}

func {{ $msg.ToFuncName $metadata }}(fields []*registry.DecodedField) any {
    {{- template "return" wrap (newWrapItem "msg" $msg) }}
}

    {{- range $field := $msg.Fields }}
        {{- template "field2func" wrap (newWrapItem "field" $field) -}}
    {{- end }} {{/* range fields */}}
{{- end }} {{/* range messages */}}

{{ define "field2func" }}
    {{- $field := .field }}
    {{- $meta := .generator.Metadata }}
    {{- $generator := .generator }}

    {{- $seen := $generator.IsSeen $field.FullTypeName }}
    {{- if not $seen -}}
        {{- $ignore := $generator.Seen $field.FullTypeName }}
        {{- if and $field.IsOptional $field.IsPrimitive }}
        func {{ $field.ToFuncName $meta}}(in *registry.DecodedField) *{{ $field.ReturnType $meta }} {
            var out *{{ $field.GetType }}

            if v, ok := in.Value.({{ $field.GetType }}); ok {
                if v != {{ $generator.NoneOptionalFieldComparator $field }} {
                    panic("expected none")
                }
            } else {
                out = in.Value.(*{{ $field.GetType }})
            }
            return out
        }
        {{- else if and $field.IsPrimitive $field.IsRepeated}}
        {{- template "repeatedPrimitive" wrap (newWrapItem "field" $field) }}
        {{- else if $field.IsOneOf }}
        {{- template "oneOfFunc" wrap (newWrapItem "field" $field) }}
        {{- end }} {{/* isOptional and isPrimitive */}}
    {{- end }} {{/* not seen */}}
{{ end }}

{{ define "repeatedPrimitive" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $goType := $field.ToGoTypeName $meta }}

func {{ $field.ToFuncName $meta}}(fields []*registry.DecodedField) {{ $field.ReturnType $meta }} {
	out := make([]{{ $goType }}, len(fields))
	for _, f := range fields {
		out = append(out, f.Value.({{ $goType }}))
	}
	return out
}
{{- end -}}

{{ define "return" }}
    {{- $msg := .msg }}
    {{- $meta := .generator.Metadata }}
    out := {{ $msg.OutputType $meta }}{}
    {{- range $i, $field := $msg.Fields }}
    {{- if $field.IsOneOf }}
        {{ template "oneOfSwitch" wrap (newWrapItem "field" $field "msgOutputType" ($msg.OutputType $meta)) }}
    {{- else }}
        {{- if and $field.IsPrimitive (not $field.IsRepeated) }}
        out.{{ $field.ToFieldName }} = fields[{{$i}}].Value.({{ $field.OutputType $meta }})
        {{- else }}
        out.{{ $field.ToFieldName }} = {{ $field.ToFuncName $meta }}(fields[{{$i}}].Value.([]*registry.DecodedField))
        {{- end }}
        {{- end }}
    {{- end }}
    return out
{{- end -}}

{{ define "oneOfSwitch" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $generator := .generator }}
{{- $msgOutputType := .msgOutputType }}
{{- $idToField := .generator.IdToField }}
{{- $goType := $field.ToGoTypeName $meta }}
{{$variantChildIds := $generator.VariantChildIds $field.LookupID}}
    //===========
    switch {
    {{- range $i, $ids := $variantChildIds }}
    {{ $t := index $field.Types $i}}
    case matchFields(fields, {{$ids}}):
    out.Value = {{ $t.ToFuncName $meta}}(fields) //Passthrough fields...
    {{- end }}
    }
    //============
{{- end -}}

{{ define "oneOfFunc" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $goType := $field.ToGoTypeName $meta }}

func {{ $field.ToFuncName $meta}}(fields []*registry.DecodedField) any {
    ===========
    {{- range $t := $field.Types }}
    {{- $t.Name}}
    {{- end }}
    ==========
    var out *{{ $field.OutputType $meta }}
    out.Value = {{ $field.ToFuncName $meta}}(fields) //Passthrough fields...
	return out
}
{{- end -}}

func matchFields(fields []*registry.DecodedField, ids []int64) bool {
	if len(fields) != len(ids) {
		return false
	}
	for i, f := range fields {
		if ids[i] != f.LookupIndex{
			return false
		}
	}
	return true
}