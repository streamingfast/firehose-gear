package gen_types

import (
    "github.com/centrifuge/go-substrate-rpc-client/v4/registry"
    pbgear "github.com/streamingfast/firehose-gear/pb/sf/gear/metadata/type/v1"
)

{{- $generator := . }}
{{- $metadata := $generator.Metadata }}
{{- $messages := $generator.Messages }}

{{ range $msg := $messages }}
{{/*{{- if or (eq $msg.Pallet "Balances") (eq $msg.Pallet "")}}*/}}

func {{ $msg.ToFuncName $metadata }}(fields []*registry.DecodedField) {{ $msg.ReturnType $metadata }} {
    {{- template "return" wrap (newWrapItem "msg" $msg) }}
}

    {{- range $field := $msg.Fields }}
        {{- template "fieldFunc" wrap (newWrapItem "field" $field) -}}
    {{- end }} {{- /* range fields */}}
{{- end }} {{- /* range messages */}}
{{/*{{- end }}*/}}

{{ define "fieldFunc" }}
    {{- $field := .field }}
    {{- $meta := .generator.Metadata }}
    {{- $generator := .generator }}
    {{- $seen := $generator.IsSeen $field.FullTypeName }}
    {{- if not $seen }}
        // not seen "{{ $field.Name}}" optional: {{$field.IsOptional}} repeated: {{$field.IsRepeated}}
        {{- if $field.IsPrimitive }}
            {{- /* ============================= */}}
            {{- /* PRIMITIVE                     */}}
            {{- /* ============================= */}}
            {{- if $field.IsOptional }}
                // optional primitive: {{ $field.Name}}
            {{- end}}
            {{- if $field.IsRepeated }}
                // optional primitive: {{ $field.Name}}
                {{- template "repeatedPrimitiveField" wrap (newWrapItem "field" $field) }}
            {{- end}}
        {{- end }}
        {{- if not $field.IsPrimitive }}
            {{- /* ============================= */}}
            {{- /* NOT PRIMITIVE                 */}}
            {{- /* ============================= */}}
            {{- if $field.IsOptional }}
                // optional field: {{ $field.Name}}
            {{- end}}
            {{- if $field.IsRepeated }}
                // optional primitive: {{ $field.Name}}
                {{- template "repeatedField" wrap (newWrapItem "field" $field) }}
            {{- end}}

        {{- end }}
        {{- /* ============================= */}}
        {{- /* SET SEEN                      */}}
        {{- /* ============================= */}}
        {{- $ignore := $generator.Seen $field.FullTypeName }}
    {{- end }} {{- /* not seen */}}
{{- end }}

{{- /* ============================= */}}
{{- /* OPTIONAL PRIMITIVE            */}}
{{- /* ============================= */}}

{{- define "optionalPrimitive" }}
{{- $field := .field }}
{{- $generator := .generator }}
{{- $meta := .generator.Metadata }}
?????????????????????????
func {{ $field.ToFuncName $meta}}(in *registry.DecodedField) *{{ $field.ReturnType $meta }} {
    var out *{{ $field.GetType }}

    if v, ok := in.Value.({{ $field.GetType }}); ok {
        if v != {{ $generator.NoneOptionalFieldComparator $field }} {
            panic("expected none")
        }
    } else {
        out = in.Value.(*{{ $field.GetType }})
    }
    return out
}

{{- end }}

{{- /* ============================= */}}
{{- /* REPEATED FIELD                */}}
{{- /* ============================= */}}
{{ define "repeatedField" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $goType := $field.ToGoTypeName $meta }}
func {{ $field.ToFuncName $meta}}(fields []*registry.DecodedField) {{ $field.ReturnType $meta }} {
    out := make([]*{{ $goType }}, len(fields))
    for _, f := range fields {
        out = append(out, {{$field.ToChildFuncName $meta}}(f.Value.([]*registry.DecodedField)))
    }
    return out
}
{{- end }}

{{- /* ============================= */}}
{{- /* REPEATED PRIMITIVE            */}}
{{- /* ============================= */}}
{{ define "repeatedPrimitiveField" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $goType := $field.ToGoTypeName $meta }}

func {{ $field.ToFuncName $meta}}(fields []*registry.DecodedField) {{ $field.ReturnType $meta }} {
	out := make([]{{ $goType }}, len(fields))
	for _, f := range fields {
		out = append(out, f.Value.({{ $goType }}))
	}
	return out
}
{{- end -}}

{{- /* ============================= */}}
{{- /* RETURN                        */}}
{{- /* ============================= */}}
{{ define "return" }}
    {{- $msg := .msg }}
    {{- $meta := .generator.Metadata }}
    out := {{ $msg.OutputType $meta }}{}

    {{- range $i, $field := $msg.Fields }}
    {{- if $field.IsOneOf }}
        {{ template "oneOfSwitch" wrap (newWrapItem "field" $field "msgOutputType" ($msg.OutputType $meta) "parentFullTypeName" $msg.FullTypeName)}}
    {{- else }}
        {{- if and (and $field.IsPrimitive (not $field.IsRepeated)) (eq $field.Name "bytes") }}
        out.{{ $field.ToFieldName }} = fields[{{$i}}].Value.({{ $field.OutputType $meta }})
        {{- else }}
        out.{{ $field.ToFieldName }} = {{ $field.ToFuncName $meta }}(fields[{{$i}}].Value.([]*registry.DecodedField))
        {{- end }}
        {{- end }}
    {{- end }}
    return out
{{- end -}}

{{- /* ============================= */}}
{{- /* ONE OF SWITCH                 */}}
{{- /* ============================= */}}
{{ define "oneOfSwitch" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $generator := .generator }}
{{- $msgOutputType := .msgOutputType }}
{{- $parentFullTypeName := .parentFullTypeName }}

{{- $idToField := .generator.IdToField }}
{{- $goType := $field.ToGoTypeName $meta }}
{{- $variantChildIds := $generator.VariantChildIds $field.LookupID}}
    switch {
    {{- range $i, $ids := $variantChildIds }}
    {{- $t := index $field.Types $i}}
    case matchFields(fields, {{$ids}}):
        out.Value = &pbgear.{{$parentFullTypeName}}_{{$t.Name}}{
            {{$t.Name}}: {{ $t.ToFuncName $meta}}(fields), //Passthrough fields...
        }
    {{- end }}
    }
{{- end -}}


func matchFields(fields []*registry.DecodedField, ids []int64) bool {
	if len(fields) != len(ids) {
		return false
	}
	for i, f := range fields {
		if ids[i] != f.LookupIndex{
			return false
		}
	}
	return true
}

func To_bytes(fields []*registry.DecodedField) []byte {
    var out []byte

    data := fields[0].Value.([]interface{})
    for _, f := range data {
        u := uint8(f.(types.U8))
        out = append(out, byte(u))
    }
    return out
}

func To_string(fields []*registry.DecodedField) string {
    return string(To_bytes(fields))
}

func To_uint32(fields []*registry.DecodedField) uint32 {
    return fields[0].Value.(uint32)
}

func To_uint64(fields []*registry.DecodedField) uint64 {
    return fields[0].Value.(uint64)
}

func To_bool(fields []*registry.DecodedField) bool {
    return fields[0].Value.(bool)
}

func To_optional_string(fields []*registry.DecodedField) *string {
    return string(To_bytes(fields))
}

func To_optional_uint32(fields []*registry.DecodedField) *uint32 {
    return fields[0].Value.(*uint32)
}

func To_optional_uint64(fields []*registry.DecodedField) *uint64 {
    return fields[0].Value.(*uint64)
}

func To_optional_bool(fields []*registry.DecodedField) *bool {
    return fields[0].Value.(*bool)
}
