package gen_types

import (
    "github.com/centrifuge/go-substrate-rpc-client/v4/registry"
    "github.com/centrifuge/go-substrate-rpc-client/v4/types"
    pbgear "github.com/streamingfast/firehose-gear/pb/sf/gear/metadata/type/v1"
)

{{- $generator := . }}
{{- $metadata := $generator.Metadata }}
{{- $messages := $generator.Messages }}

{{- range $msg := $messages }}
{{/*{{- if or (eq $msg.Pallet "Balances") (eq $msg.Pallet "")}}*/}}
{{- $funcName := $msg.ToFuncName $metadata }}
{{- if eq $funcName "To_TupleNull" }}
    func {{ $funcName }}() {{ $msg.ReturnType $metadata }} {
{{- else }}
    func {{ $funcName }}(in {{ $generator.TypeForField $msg }}) {{ $msg.ReturnType $metadata }} {
{{- end }}
    {{template "funcBody" wrap (newWrapItem "lookable" $msg "fields" $msg.Fields "outputType" ($msg.OutputType $metadata) "parentFullTypeName" ($msg.FullTypeName)) }}
}

{{- range $field := $msg.Fields }}
    {{- template "fieldFunc" wrap (newWrapItem "field" $field) -}}
{{- end }} {{- /* range fields */}}

{{- end }} {{- /* range messages */}}
{{/*{{- end }}*/}}

{{ define "funcBody" }}
    {{- $lookable := .lookable }}
    {{- $fields := .fields }}
    {{- $generator := .generator }}
    {{- $meta := .generator.Metadata }}
    {{- $outputType := .outputType }}
    {{- $parentFullTypeName := .parentFullTypeName }}
    {{- $type := $generator.TypeForField $lookable }}
    {{- if eq $type "types.UCompact"}}
        {{- $field := index $fields 0 }}
        {{- $childType := $generator.CompactChildType $field  }}
        {{- if $childType.IsPrimitive }}
            //{{ $outputType }}
            return nil
        {{- else }}
            out := {{ $outputType }}{}
            {{- $funcName := $field.ToFuncName $meta }}
            {{- if eq $funcName "To_TupleNull" }}
                out.{{ $field.ToFieldName }} = {{ $funcName }}()
            {{- else }}
                out.{{ $field.ToFieldName }} = {{ $funcName }}(in)
            {{- end }}
            return out
        {{- end }}
    {{- else }}
        {{- if eq $outputType "&pbgear.TupleNull"}}
        {{- else }}
            fields := []*registry.DecodedField(in)
            _ = fields
        {{- end}}
    {{- template "return" wrap (newWrapItem "fields" $fields "outputType" $outputType "parentFullTypeName" $parentFullTypeName) }}
    {{- end }}
{{- end }}

{{- /* ============================= */}}
{{- /* RETURN                        */}}
{{- /* ============================= */}}
{{ define "return" }}
{{- $generator := .generator }}
{{- $meta := .generator.Metadata }}
{{- $fields := .fields }}
{{- $outputType := .outputType }}
{{- $parentFullTypeName := .parentFullTypeName }}
    out := {{ $outputType }}{}

    {{- range $i, $field := $fields }}
    {{- if $field.IsOneOf }}
        {{ template "oneOfSwitch" wrap (newWrapItem "field" $field "msgOutputType" $outputType "parentFullTypeName" $parentFullTypeName)}}
    {{- else }}
        {{- if eq $field.Type "bytes"}}
            out.{{ $field.ToFieldName }} = {{ $field.ToFuncName $meta }}(fields[{{$i}}].Value.([]interface{}))
        {{- else }}
            out.{{ $field.ToFieldName }} = {{ $field.ToFuncName $meta }}(fields[{{$i}}].Value.({{ $generator.TypeForField $field }}))
        {{ end }}
    {{- end }}
    {{- end }}
    return out
{{- end -}}

{{ define "fieldFunc" }}
    {{- $field := .field }}
    {{- $meta := .generator.Metadata }}
    {{- $generator := .generator }}
    {{- if not $field.IsPrimitive }}
        {{- /* ============================= */}}
        {{- /* NOT PRIMITIVE                 */}}
        {{- /* ============================= */}}
        {{- if $field.IsOptional }}
            {{- $optKey := printf "%sopt%t" $field.FullTypeName $field.IsOptional}}
            {{- $seen := $generator.IsSeen $optKey }}
            {{- if not $seen }}
                {{- template "optionalField" wrap (newWrapItem "field" $field) }}
                {{- $ignore := $generator.Seen $optKey}}
            {{- end }}
        {{- end}}
        {{- if $field.IsRepeated }}
            {{- $repKey := printf "%srep%t" $field.FullTypeName $field.IsRepeated}}
            {{- $seen := $generator.IsSeen $repKey }}
            {{- if not $seen }}
                {{- template "repeatedField" wrap (newWrapItem "field" $field) }}
                {{- $ignore := $generator.Seen $repKey}}
            {{- end }}
        {{- end }}

    {{- end }}
{{- end }}


{{- /* ============================= */}}
{{- /* TODO ONE OF FIELD SELECTION   */}}
{{- /* ============================= */}}


{{- /* ============================= */}}
{{- /* REPEATED FIELD                */}}
{{- /* ============================= */}}
{{ define "repeatedField" }}
{{- $field := .field }}
{{- $generator := .generator }}
{{- $meta := .generator.Metadata }}
{{- $goType := $field.ToGoTypeName $meta }}
func {{ $field.ToFuncName $meta}}(f {{ $generator.TypeForField $field }}) {{ $field.ReturnType $meta }} {
    fields := []*registry.DecodedField(f)
    _ = fields

    out := make([]*{{ $goType }}, len(fields))
    for _, f := range fields {
        out = append(out, {{$field.ToChildFuncName $meta}}(f.Value.([]*registry.DecodedField)))
    }
    return out
}
{{- end }}
{{- /* ============================= */}}
{{- /* OPTIONAL FIELD                */}}
{{- /* ============================= */}}
{{ define "optionalField" }}
    {{- $field := .field }}
    {{- $generator := .generator }}
    {{- $meta := .generator.Metadata }}
    {{- $goType := $field.ToGoTypeName $meta }}
    func {{ $field.ToFuncName $meta}}(f {{ $generator.TypeForField $field }}) {{ $field.ReturnType $meta }} {
        fields := []*registry.DecodedField(f)
        _ = fields

        var out = {{$field.ToChildFuncName $meta}}(fields)
        return out
    }
{{- end }}

{{- /* ============================= */}}
{{- /* ONE OF SWITCH                 */}}
{{- /* ============================= */}}
{{ define "oneOfSwitch" }}
{{- $field := .field }}
{{- $meta := .generator.Metadata }}
{{- $generator := .generator }}
{{- $msgOutputType := .msgOutputType }}
{{- $parentFullTypeName := .parentFullTypeName }}

{{- $idToField := .generator.IdToField }}
{{- $goType := $field.ToGoTypeName $meta }}
{{- $variantChildIds := $generator.VariantChildIds $field.LookupID}}
    switch {
    {{- range $i, $ids := $variantChildIds }}
    {{- $t := index $field.Types $i}}
    case matchFields(fields, {{$ids}}):
        out.{{$field.ToFieldName}} = &pbgear.{{$parentFullTypeName}}_{{$t.ToFieldName}}{
            {{$t.ToFieldName}}: {{ $t.ToFuncName $meta}}(fields), //Passthrough fields...
        }
    {{- end }}
    }
{{- end -}}


func matchFields(f registry.DecodedFields, ids []int64) bool {
    fields := []*registry.DecodedField(f)

	if len(fields) != len(ids) {
		return false
	}
	for i, f := range fields {
		if ids[i] != f.LookupIndex{
			return false
		}
	}
	return true
}

func To_bytes(f []interface{}) []byte {
    var out []byte
    for _, f := range f {
        u := uint8(f.(types.U8))
        out = append(out, byte(u))
    }
    return out
}

func To_string(f registry.DecodedFields) string {
    fields := []*registry.DecodedField(f)

    return string(To_bytes(fields[0].Value.([]interface{})))
}

func To_uint32(f registry.DecodedFields) uint32 {
    fields := []*registry.DecodedField(f)

    return fields[0].Value.(uint32)
}

func To_uint64(f registry.DecodedFields) uint64 {
    fields := []*registry.DecodedField(f)

    return fields[0].Value.(uint64)
}

func To_bool(f registry.DecodedFields) bool {
    fields := []*registry.DecodedField(f)

    return fields[0].Value.(bool)
}

func To_optional_string(f registry.DecodedFields) *string {
    fields := []*registry.DecodedField(f)

    s := string(To_bytes(fields[0].Value.([]interface{})))
    return &s
}

func To_optional_uint32(f registry.DecodedFields) *uint32 {
    fields := []*registry.DecodedField(f)

    return fields[0].Value.(*uint32)
}

func To_optional_uint64(f registry.DecodedFields) *uint64 {
    fields := []*registry.DecodedField(f)

    return fields[0].Value.(*uint64)
}

func To_optional_bool(f registry.DecodedFields) *bool {
    fields := []*registry.DecodedField(f)

    return fields[0].Value.(*bool)
}

func To_repeated_uint32(f registry.DecodedFields) []uint32 {
    fields := []*registry.DecodedField(f)

    var out []uint32
    for _, f := range fields {
        out = append(out, f.Value.(uint32))
    }
    return out
}
